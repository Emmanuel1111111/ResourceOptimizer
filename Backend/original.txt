from datetime import datetime, time
from flask import jsonify, request, Blueprint
import pandas as pd
from bson import ObjectId
from pymongo import MongoClient
from pymongo.errors import PyMongoError
from dotenv import load_dotenv
import os
load_dotenv()

# Setup Flask blueprint and MongoDB
manage_resources_bp = Blueprint('routes_bp', __name__)
MONGO_URI = os.getenv("MONGO_URI")
client = MongoClient(MONGO_URI)
db = client['EduResourceDB']
timetables = db['timetables']
 # Assuming you have a rooms collection
# Note: You'll need to define preprocess_data and is_within_time_and_day functions

def validate_time_format(time_str):
    """
    Validate time format and return True if valid, False otherwise.
    """
    if not isinstance(time_str, str):
        return False
    
    # Check if time_str contains ':'
    if ':' not in time_str:
        return False
    
    parts = time_str.split(':')
    if len(parts) != 2:
        return False
    
    hours_str, minutes_str = parts
    
    # Check if both parts are digits
    if not (hours_str.isdigit() and minutes_str.isdigit()):
        return False
    
    try:
        hours, minutes = int(hours_str), int(minutes_str)
        # Validate range
        if not (0 <= hours <= 23 and 0 <= minutes <= 59):
            return False
        return True
    except ValueError:
        return False

def normalize_time_format(time_str):
    """
    Normalize different time formats to HH:MM format.
    Handles formats like "8:00", "08:00", "8:00–9:55" (with en dash)
    """
    if not time_str or not isinstance(time_str, str):
        return time_str
    
    print(f"Normalizing time format: '{time_str}'")
    
    # Handle special characters like en dash or em dash that might be in the data
    if '–' in time_str:  # en dash (common in the provided data)
        time_str = time_str.split('–')[0].strip()
        print(f"  → Split at en dash: '{time_str}'")
    elif '-' in time_str and ':' in time_str:  # hyphen used as separator
        time_str = time_str.split('-')[0].strip()
        print(f"  → Split at hyphen: '{time_str}'")
    elif '—' in time_str:  # em dash
        time_str = time_str.split('—')[0].strip()
        print(f"  → Split at em dash: '{time_str}'")
    
    # If time is already in HH:MM format, return it
    if validate_time_format(time_str):
        print(f"  → Already valid: '{time_str}'")
        return time_str
    
    # Try to parse hour and minute
    try:
        # If it's just a number, assume it's hours
        if time_str.isdigit():
            result = f"{int(time_str):02d}:00"
            print(f"  → Converted digit to time: '{result}'")
            return result
        
        # If it has a colon, try to format properly
        if ':' in time_str:
            hour, minute = time_str.split(':')
            result = f"{int(hour):02d}:{int(minute):02d}"
            print(f"  → Formatted with leading zeros: '{result}'")
            return result
    except (ValueError, TypeError) as e:
        print(f"  → Error parsing time: {e}")
    
    # If we can't normalize it, return as is
    print(f"  → Could not normalize, returning as is: '{time_str}'")
    return time_str

def has_time_overlap(start1, end1, start2, end2):
    """
    A more robust helper function to check if two time periods overlap.
    This function specifically handles the case where one period ends exactly 
    when another begins (which should NOT count as an overlap).
    
    Args:
        start1, end1: Start and end times of first period (HH:MM format)
        start2, end2: Start and end times of second period (HH:MM format)
        
    Returns:
        bool: True if there is an overlap, False otherwise
    """
    try:
        # Convert strings to datetime.time objects
        s1 = datetime.strptime(start1, '%H:%M').time()
        e1 = datetime.strptime(end1, '%H:%M').time()
        s2 = datetime.strptime(start2, '%H:%M').time()
        e2 = datetime.strptime(end2, '%H:%M').time()
        
        # If either period has zero duration, no overlap
        if s1 == e1 or s2 == e2:
            return False
            
        # IMPORTANT: The key comparison - specifically exclude the case
        # where one period ends exactly when another begins
        if e1 == s2 or e2 == s1:
            return False
            
        # Standard overlap check
        return s1 < e2 and e1 > s2
        
    except (ValueError, TypeError) as e:
        print(f"Error in has_time_overlap: {e}")
        # Return True to be safe
        return True

def serialize_mongo_doc(doc):
    """
    Serialize a MongoDB document for JSON response.
    Converts ObjectId to string and handles other non-serializable types.
    
    Args:
        doc: MongoDB document (dict)
        
    Returns:
        dict: Serialized document safe for JSON conversion
    """
    if not doc:
        return doc
        
    serialized = {}
    for key, value in doc.items():
        # Handle ObjectId
        if key == '_id' and isinstance(value, ObjectId):
            serialized[key] = str(value)
        # Handle nested documents
        elif isinstance(value, dict):
            serialized[key] = serialize_mongo_doc(value)
        # Handle lists of documents
        elif isinstance(value, list) and all(isinstance(item, dict) for item in value):
            serialized[key] = [serialize_mongo_doc(item) for item in value]
        # Handle other types
        else:
            serialized[key] = value
            
    return serialized

@manage_resources_bp.route('/manage_resources', methods=['POST'])
def manage_resources():
   
    try:
        data = request.get_json()
        if not data or 'operation' not in data:
            return jsonify({'error': 'Missing operation in request'}), 400

        operation = data.get('operation')
        room_id = data.get('room_id')
        date = data.get('date', datetime.now().strftime('%Y-%m-%d'))
        start_time = data.get('start_time')
        end_time = data.get('end_time')
        day = data.get('day', datetime.now().strftime('%A'))
        schedule_id = data.get('schedule_id')
        new_schedule = data.get('new_schedule', {})
        department = data.get('department')

        
        # Check if day parameter was explicitly provided in the request
        day_provided_in_request = 'day' in data and data['day']
        
        # If date is provided, validate it and get the day of week
        if date:
            try:
                date_obj = datetime.strptime(date, '%Y-%m-%d')
                inferred_day = date_obj.strftime('%A')
                
                # Only override the day if it wasn't explicitly provided in the request
                if not day_provided_in_request:
                    day = inferred_day
                    print(f"Day not provided in request, using inferred day: {day}")
                else:
                    print(f"Using day provided in request: {day} (inferred from date: {inferred_day})")
            except ValueError:
                return jsonify({'error': 'Invalid date format, use YYYY-MM-DD'}), 400
        
        # Ensure day is valid
        valid_days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
        if day not in valid_days:
            return jsonify({'error': f'Invalid day format. Must be one of: {", ".join(valid_days)}'}), 400
            
        print(f"Final day used for scheduling: {day}")

        
        def check_overlap(start1, end1, start2, end2):
            """
            Check if two time periods overlap.
            Returns True if there is an overlap, False otherwise.
            Also returns False if any time format is invalid.
            """
            try:
                # Validate all time strings first
                time_strings = [start1, end1, start2, end2]
                for time_str in time_strings:
                    if not validate_time_format(time_str):
                        print(f"Invalid time format detected: {time_str}")
                        # Return True to be safe (assume there could be an overlap)
                        # This prevents scheduling when we can't validate times
                        return True
                
                # Convert to datetime.time objects for proper comparison
                # Use datetime.strptime instead of pandas for more reliable parsing
                s1 = datetime.strptime(start1, '%H:%M').time()
                e1 = datetime.strptime(end1, '%H:%M').time()
                s2 = datetime.strptime(start2, '%H:%M').time()
                e2 = datetime.strptime(end2, '%H:%M').time()
                
                # Special case: if any period has zero duration
                if s1 == e1 or s2 == e2:
                    # Zero duration periods can't overlap
                    return False
                
                # Check overlap: two periods overlap if:
                # (start1 < end2) AND (end1 > start2)
                # This excludes the case where one period starts exactly when another ends
                return s1 < e2 and e1 > s2
                
            except (ValueError, TypeError) as e:
                print(f"Error in check_overlap: {e}")
                # Return True to be safe (assume there could be an overlap)
                return True

        # Operation: Check availability
        
        if operation == 'check_overlap':
            if not all([room_id, date, start_time, end_time]):
                return jsonify({'error': 'Missing required fields: room_id, date, start_time, end_time'}), 400

            
            if not validate_time_format(start_time) or not validate_time_format(end_time):
                return jsonify({'error': 'Invalid time format for start_time or end_time. Use HH:MM format.'}), 400

            # Use the day parameter that was already processed above
            # This will be either the explicitly provided day or the one inferred from the date
            
            print(f"Checking for conflicts on {day} for room {room_id}")
                
            # IMPORTANT: Since the schedule is primarily organized by day of week,
            # we should prioritize day-based scheduling over specific dates
            
            # First query by day of week - using the provided/inferred day
            query_day = {'Room ID': room_id, 'Day': day}
            existing_schedules_by_day = list(timetables.find(query_day, {'_id': 0}))
            
            # Only if no day-based schedules are found, check for date-specific schedules
            if not existing_schedules_by_day:
                query_date = {'Room ID': room_id, 'Date': date}
                existing_schedules_by_date = list(timetables.find(query_date, {'_id': 0}))
                existing_schedules = existing_schedules_by_date
            else:
                existing_schedules = existing_schedules_by_day
            
            print(f"Found {len(existing_schedules)} potential conflicts for room {room_id} on {day} ({date})")

            conflicts = []
            for schedule in existing_schedules:
                # Get schedule details
                schedule_start = schedule.get('Start')
                schedule_end = schedule.get('End')
                schedule_day = schedule.get('Day', 'Unknown')
                schedule_date = schedule.get('Date', 'Unknown')
                schedule_course = schedule.get('Course', 'Unknown')
                
                # Handle different time formats - normalize to HH:MM if needed
                # For the specific format in your data "08:00–09:55", we need to extract both parts
                if isinstance(schedule_start, str) and '–' in schedule_start:
                    time_parts = schedule_start.split('–')
                    if len(time_parts) == 2:
                        schedule_start = time_parts[0].strip()
                        # Only update end time if it's not already set
                        if not schedule_end or not isinstance(schedule_end, str):
                            schedule_end = time_parts[1].strip()
                
                # Now normalize both times
                schedule_start = normalize_time_format(schedule_start)
                schedule_end = normalize_time_format(schedule_end)
                
                print(f"Checking schedule: Room={room_id}, Day={schedule_day}, Date={schedule_date}, " +
                      f"Time={schedule_start}-{schedule_end}, Course={schedule_course}")
                
                if not validate_time_format(schedule_start) or not validate_time_format(schedule_end):
                    # Skip schedules with invalid time formats
                    print(f"  → Skipping due to invalid time format")
                    continue
                
                overlap = check_overlap(start_time, end_time, schedule_start, schedule_end)
                print(f"  → Overlap result: {overlap}")
                
                # Make sure we're checking the right day
                if schedule_day != day and schedule_day != "Unknown":
                    print(f"  → Skipping due to day mismatch: schedule day '{schedule_day}' != requested day '{day}'")
                    continue
                
                if overlap:
                    conflict_info = {
                        'schedule_id': str(schedule.get('_id', 'Unknown')),
                        'course': schedule_course,
                        'time': f"{schedule_start}-{schedule_end}",
                        'day': schedule_day,
                        'date': schedule_date
                    }
                    conflicts.append(conflict_info)
                    print(f"  → CONFLICT DETECTED: {conflict_info}")
                else:
                    print(f"  → No conflict")

            # Create a clear response with day of week as the primary factor
            return jsonify({
                'message': 'Overlap check completed',
                'room_id': room_id,
                'day': day,  # List day first as it's more important
                'date': date,
                'proposed_time': f'{start_time}-{end_time}',
                'has_conflict': bool(conflicts),
                'conflicts': conflicts,
                'schedules_checked': len(existing_schedules),
                'search_method': 'day_based' if existing_schedules_by_day else 'date_based'
            })

        # Operation: Reallocate schedule
        elif operation == 'reallocate':
            if not schedule_id or not new_schedule:
                return jsonify({'error': 'Missing schedule_id or new_schedule'}), 400

            try:
                schedule_id = ObjectId(schedule_id)
            except:
                return jsonify({'error': 'Invalid schedule_id format'}), 400

            # Validate new schedule
            new_room_id = new_schedule.get('room_id')
            new_date = new_schedule.get('date')
            new_start_time = new_schedule.get('start_time')
            new_end_time = new_schedule.get('end_time')
            new_day = new_schedule.get('day')

            if not all([new_room_id, new_date, new_start_time, new_end_time, new_day]):
                return jsonify({'error': 'Missing fields in new_schedule'}), 400

            # Validate new schedule time formats
            if not validate_time_format(new_start_time) or not validate_time_format(new_end_time):
                return jsonify({'error': 'Invalid time format in new_schedule. Use HH:MM format.'}), 400

            # Check overlap in new room
            query = {'Room ID': new_room_id, 'Day': new_day}
            existing_schedules = list(timetables.find(query, {'_id': 0}))

            conflicts = []
            for schedule in existing_schedules:
                if str(schedule.get('Room ID')) != str(schedule_id):  # Exclude the current schedule
                    schedule_start = schedule.get('Start')
                    schedule_end = schedule.get('End')
                    
                    # Skip schedules with invalid time formats
                    if not validate_time_format(schedule_start) or not validate_time_format(schedule_end):
                        print(f"Skipping schedule with invalid time format: Start={schedule_start}, End={schedule_end}")
                        continue
                    
                    if check_overlap(new_start_time, new_end_time, schedule_start, schedule_end):
                        conflicts.append({
                            'schedule_id': str(schedule.get('_id', 'Unknown')),
                            'course': schedule.get('Course', 'Unknown'),
                            'time': f"{schedule_start}-{schedule_end}"
                        })

            if conflicts:
                return jsonify({
                    'error': 'Reallocation failed due to conflicts',
                    'conflicts': conflicts
                }), 400

            # Update schedule
            update = {
                '$set': {
                    'Room ID': new_room_id,
                    'Date': new_date,
                    'Start': new_start_time,
                    'End': new_end_time,
                    'Day': new_day
                }
            }
            result = timetables.update_one({'Room ID': schedule_id}, update)

            if result.matched_count == 0:
                return jsonify({'error': 'Schedule not found'}), 404

            return jsonify({
                'message': 'Schedule reallocated successfully',
                'schedule_id': str(schedule_id),
                'new_schedule': new_schedule
            })

        # Operation: Inject new schedule
        elif operation == 'inject_schedule':
            try:
                if not all([room_id, date, start_time, end_time, day]):
                    return jsonify({'error': 'Missing required fields: room_id, date, start_time, end_time, day'}), 400
    
                # Validate time formats
                if not validate_time_format(start_time) or not validate_time_format(end_time):
                    return jsonify({'error': 'Invalid time format for start_time or end_time. Use HH:MM format.'}), 400
    
                # Check for conflicts before injection - use the day parameter instead of date
                print(f"Checking for conflicts on {day} for room {room_id} from {start_time} to {end_time}")
                
                # Query by day of week - using the provided day
                query = {'Room ID': room_id, 'Day': day}
                existing_schedules = list(timetables.find(query, {'_id': 0}))
                print(f"Found {len(existing_schedules)} schedules for room {room_id} on {day}")
    
                conflicts = []
                for schedule in existing_schedules:
                    # Get schedule details
                    schedule_start = schedule.get('Start')
                    schedule_end = schedule.get('End')
                    schedule_course = schedule.get('Course', 'Unknown')
                    
                    # Handle different time formats - normalize to HH:MM if needed
                    if isinstance(schedule_start, str) and '–' in schedule_start:
                        time_parts = schedule_start.split('–')
                        if len(time_parts) == 2:
                            schedule_start = time_parts[0].strip()
                            if not schedule_end or not isinstance(schedule_end, str):
                                schedule_end = time_parts[1].strip()
                    
                    # Normalize times
                    schedule_start = normalize_time_format(schedule_start)
                    schedule_end = normalize_time_format(schedule_end)
                    
                    print(f"Checking potential conflict: Course={schedule_course}, Time={schedule_start}-{schedule_end}")
                    
                    if not validate_time_format(schedule_start) or not validate_time_format(schedule_end):
                        print(f"  → Skipping due to invalid time format")
                        continue
                    
                    # Use our robust overlap detection
                    has_overlap = has_time_overlap(start_time, end_time, schedule_start, schedule_end)
                    print(f"  → Overlap check result: {has_overlap}")
                    
                    if has_overlap:
                        conflict = {
                            'schedule_id': str(schedule.get('_id', 'Unknown')),
                            'course': schedule_course,
                            'time': f"{schedule_start}-{schedule_end}"
                        }
                        conflicts.append(conflict)
                        print(f"  → CONFLICT DETECTED: {conflict}")
                    else:
                        print(f"  → No conflict")
    
                if conflicts:
                    return jsonify({
                        'error': 'Schedule injection failed due to conflicts',
                        'conflicts': conflicts
                    }), 400
    
                # Create new schedule document
                new_schedule_doc = {
                    'Room ID': room_id,
                    'Date': date,
                    'Start': start_time,
                    'End': end_time,
                    'Day': day,
                    'Course': data.get('course', 'Unknown'),
                    'Department': data.get('department', 'Unknown'),
                    'Lecturer': data.get('instructor', 'Unknown'),
                    'Year': data.get('year', 'Unknown'),
                    'Status': data.get('status', 'Booked')
                }
    
                # Insert into database
                result = timetables.insert_one(new_schedule_doc)
                
                # Serialize the document for JSON response
                response_doc = serialize_mongo_doc(new_schedule_doc)
                
                return jsonify({
                    'message': 'Schedule injected successfully',
                    'schedule_id': str(result.inserted_id),
                    'schedule': response_doc
                })
                
            except Exception as e:
                print(f"Error in inject_schedule: {str(e)}")
                return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

        # Operation: Get schedules for a room on a specific day
        elif operation == 'get_room_schedules':
            try:
                if not room_id:
                    return jsonify({'error': 'Missing required field: room_id'}), 400
                
                # Use day if provided, otherwise get all schedules
                query = {'Room ID': room_id}
                if day:
                    query['Day'] = day
                
                # Get all schedules for this room and day
                schedules = list(timetables.find(query, {'_id': 0}))
                
                # Format times consistently for display
                for schedule in schedules:
                    start = schedule.get('Start', '')
                    end = schedule.get('End', '')
                    if start and end:
                        schedule['Time'] = f"{start}–{end}"  # Using en dash for consistency
                
                # Serialize for JSON response
                serialized_schedules = [serialize_mongo_doc(s) for s in schedules]
                
                return jsonify({
                    'message': f'Found {len(schedules)} schedules',
                    'room_id': room_id,
                    'day': day if day else 'All days',
                    'schedules': serialized_schedules
                })
                
            except Exception as e:
                print(f"Error in get_room_schedules: {str(e)}")
                return jsonify({'error': f'Unexpected error: {str(e)}'}), 500
                
        # Operation: Suggest rooms
        elif operation == 'suggest_rooms':
            if not date or not start_time or not end_time:
                return jsonify({'error': 'Missing date, start_time, or end_time'}), 400

            # Skip weekends
            try:
                date_obj = datetime.strptime(date, '%Y-%m-%d')
                if date_obj.weekday() >= 5:  # Saturday=5, Sunday=6
                    return jsonify({'message': 'No room suggestions for weekends', 'suggested_rooms': []})
            except ValueError:
                return jsonify({'error': 'Invalid date format'}), 400

            # Validate time formats
            if not validate_time_format(start_time) or not validate_time_format(end_time):
                return jsonify({'error': 'Invalid time format for start_time or end_time. Use HH:MM format.'}), 400

            # Fetch all rooms
            all_rooms = list(timetables.find({}, {'_id': 0}))

            # Fetch schedules for the date
            query = {'Day': day}
            schedules = list(timetables.find(query, {'_id': 0}))
            df_schedules = pd.DataFrame(schedules)

            # Filter free rooms
            free_rooms = []
            if not df_schedules.empty:
                # Create a list of available rooms by checking overlaps
                booked_room_ids = set()
                
                for _, schedule in df_schedules.iterrows():
                    schedule_start = schedule.get('Start')
                    schedule_end = schedule.get('End')
                    
                    # Skip schedules with invalid time formats
                    if not validate_time_format(schedule_start) or not validate_time_format(schedule_end):
                        print(f"Skipping schedule with invalid time format: Start={schedule_start}, End={schedule_end}")
                        continue
                    
                    if check_overlap(start_time, end_time, schedule_start, schedule_end):
                        booked_room_ids.add(schedule['Room ID'])
                
                free_rooms = [room for room in all_rooms if room['Room ID'] not in booked_room_ids]
            else:
                free_rooms = all_rooms

            if not free_rooms:
                return jsonify({'message': 'No free rooms available', 'suggested_rooms': []})

            # Simple room list - just return available rooms
            suggested_rooms = []
            for room in free_rooms:
                suggested_rooms.append({
                    'room_id': room['Room ID'],
                    'department': room.get('Department', 'Unknown')
                })

            return jsonify({
                'message': 'Room suggestions generated',
                'date': date,
                'time': f'{start_time}-{end_time}',
                'suggested_rooms': suggested_rooms
            })

        # Operation: Get schedules for a room on a specific day
        elif operation == 'get_room_schedules':
            try:
                if not room_id:
                    return jsonify({'error': 'Missing required field: room_id'}), 400
                
                # Use day if provided, otherwise get all schedules
                query = {'Room ID': room_id}
                if day:
                    query['Day'] = day
                
                # Get all schedules for this room and day
                schedules = list(timetables.find(query, {'_id': 0}))
                
                # Format times consistently for display
                for schedule in schedules:
                    start = schedule.get('Start', '')
                    end = schedule.get('End', '')
                    if start and end:
                        schedule['Time'] = f"{start}–{end}"  # Using en dash for consistency
                
                # Serialize for JSON response
                serialized_schedules = [serialize_mongo_doc(s) for s in schedules]
                
                return jsonify({
                    'message': f'Found {len(schedules)} schedules',
                    'room_id': room_id,
                    'day': day if day else 'All days',
                    'schedules': serialized_schedules
                })
                
            except Exception as e:
                print(f"Error in get_room_schedules: {str(e)}")
                return jsonify({'error': f'Unexpected error: {str(e)}'}), 500

        else:
            return jsonify({'error': f'Invalid operation: {operation}'}), 400

    except KeyError as e:
        return jsonify({'error': f'Key error: {str(e)}'}), 400
    except PyMongoError as e:
        return jsonify({'error': f'Database error: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Unexpected error: {str(e)}'}), 500


    